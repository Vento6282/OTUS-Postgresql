# Блокировки. 

Занятие от 6.05.2024

## Выполнение домашнего задания:

 - Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.

Запрос включения вывода сообщений в журнал сервера:
```
alter system set log_lock_waits = on;
```
Запрос установки вывода сообщений об ожидании дольше 200ms:
```
 alter system set deadlock_timeout = 200;
```
Вывод файла ***/var/log/postgresql/postgresql-15-main.log***:
```
2024-05-14 17:35:18.990 MSK [4049] postgres@accounts LOG:  process 4049 still waiting for ShareLock on transaction 2611240 after 200.217 ms

2024-05-14 17:35:43.221 MSK [4049] postgres@accounts LOG:  process 4049 acquired ShareLock on transaction 2611240 after 24431.224 ms
```

 - Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.
Ответ:
```
ExclusiveLock - монопольная блокировка, то есть доступ к объекту имеет только одна транзакция/сеанс. Другие транзакции не могут получить никакой разделяемой блокировки. Монопольная блокировка не совместима с любыми типами блокировок. 

ShareLock - разделяемая блокировка. Вторая транзакция пытается получить разделяемую блокировку для нужной записи. Доступ предоставлен не был, так как на запись наложена монопольная блокировка (ExclusiveLock) первой транзакции. Вторая транзакция ждёт завершения первой.

RowExclusiveLock - блокировка в этом режиме получает любая команда, которая изменяет данные в таблице.
```
 - Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?

Ответ: информации вполне хватает, чтобы разобраться почему произошла взаимоблокировка, кто какие процессы ожидал, и какие запросы при этом участвовали.

Вывод файла ***/var/log/postgresql/postgresql-15-main.log***:
```
2024-05-15 10:25:12.163 MSK [17365] postgres@accounts ERROR:  deadlock detected
2024-05-15 10:25:12.163 MSK [17365] postgres@accounts DETAIL:  
        Process 17365 waits for ShareLock on transaction 2611256; blocked by process 4044.
        Process 4044 waits for ShareLock on transaction 2611257; blocked by process 17355.
        Process 17355 waits for ShareLock on transaction 2611258; blocked by process 17365.
        Process 17365: update accounts set amount = 7000 where acc_no = 1;
        Process 4044: update accounts set amount = 9000 where acc_no = 2;
        Process 17355: update accounts set amount = 1000 where acc_no = 3;
```
 - Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?

Ответ: такая ситуация возможна, если изменить порядок обращения к записям в таблице. Например, первый запрос обновляет данные так, как они есть в таблице, а второй запрос обновлеяет данные, получая их из индекса.

 - Задание со звездочкой*\
 Попробуйте воспроизвести такую ситуацию.
 Ответ: к сожалению, не смог придумать как реализовать это.